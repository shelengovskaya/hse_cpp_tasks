Рассмотрим последовательность целых чисел длины n. По ней с шагом 1 двигается «окно» длины k, то есть сначала в «окне» видны первые k чисел, на следующем шаге в «окне» уже будут находиться k чисел, начиная со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить минимум в нём.

Формат ввода
В первой строке входных данных содержатся два натуральных числа n и k (n ≤  150000, k ≤ 10000, k ≤  n) – длины последовательности и «окна», соответственно. На следующей строке находятся n чисел – сама последовательность.

Формат вывода
Выходые данные должны содержать n - k + 1 строк – минимумы для каждого положения «окна».

#include <iostream>
#include <vector>
#include <set>


using namespace std;



int main() {
    multiset<int> s;
    int n, k;
    cin >> n >> k;
    vector<int> vec(n);
    int x;
    for(size_t i = 0; i < k; i++) {
        cin >> x;
        s.insert(x);
        vec[i] = x;
    }
    cout << *s.begin() << "\n";
    auto iter = s.find(vec[0]);
    auto s_iter = iter;
    s.erase(iter, ++s_iter);
    for(size_t i = k; i < n; i++) {
        cin >> x;
        s.insert(x);
        vec[i] = x;
        cout << *s.begin() << "\n";
        auto iter = s.find(vec[i - k + 1]);
        auto s_iter = iter;
        s.erase(iter, ++s_iter);
    }
    return 0;
}
